import unittest
from unittest.mock import patch, MagicMock, mock_open
import random
import sys

sys.path.append('.')
import spellcheck

class TestSwapAdjacentLetters(unittest.TestCase):
    def test_swap_adjacent_letters_basic(self):
        with patch('random.randint', return_value=0):
            result = spellcheck.swap_adjacent_letters("hello")
            self.assertEqual(result, "ehllo")
    
    def test_swap_adjacent_letters_short(self):
        result = spellcheck.swap_adjacent_letters("a")
        self.assertEqual(result, "a")
        
        with patch('random.randint', return_value=0):
            result = spellcheck.swap_adjacent_letters("ab")
            self.assertEqual(result, "ba")
    
    def test_swap_adjacent_letters_long(self):
        with patch('random.randint', return_value=2):
            result = spellcheck.swap_adjacent_letters("python")
            self.assertEqual(result, "pyhton")

class TestChangeU(unittest.TestCase):
    def test_change_u_no_u_or_o(self):
        result = spellcheck.change_u("krzak")
        self.assertEqual(result, "krzak")

class TestChangeRz(unittest.TestCase):
    def test_change_rz_no_rz_or_z(self):
        result = spellcheck.change_rz("kot")
        self.assertEqual(result, "kot")

class TestGenerateTypoDistractor(unittest.TestCase):
    def test_generate_typo_short_word(self):
        with patch('spellcheck.swap_adjacent_letters', return_value="tset"):
            result = spellcheck.generate_typo_distractor("test")
            self.assertEqual(result, "tset")
    
    def test_generate_typo_with_u(self):
        with patch('random.random', return_value=0.7):
            with patch('spellcheck.change_u', return_value="botelka"):
                result = spellcheck.generate_typo_distractor("butelka")
                self.assertEqual(result, "botelka")
    
    def test_generate_typo_with_rz(self):
        with patch('random.random', return_value=0.7):
            with patch('spellcheck.change_rz', return_value="pżyjaciel"):
                result = spellcheck.generate_typo_distractor("przyjaciel")
                self.assertEqual(result, "pżyjaciel")
    
    def test_generate_typo_both_u_and_rz(self):
        with patch('random.random', return_value=0.3):
            with patch('spellcheck.swap_adjacent_letters', return_value="przyjacile"):
                result = spellcheck.generate_typo_distractor("przyjaciel")
                self.assertEqual(result, "przyjacile")
    
    def test_generate_typo_neither_u_nor_rz(self):
        with patch('spellcheck.swap_adjacent_letters', return_value="biogs"):
            result = spellcheck.generate_typo_distractor("bigos")
            self.assertEqual(result, "biogs")

class TestGenerateRiddle(unittest.TestCase):
    @patch('spellcheck.get_token_info')
    def test_generate_riddle_basic(self, mock_token_info):
        page = "To jest przykładowe zdanie z błędami."
        mock_token_info.return_value = [
            {'text': 'To', 'start': 0, 'end': 2},
            {'text': 'jest', 'start': 3, 'end': 7},
            {'text': 'przykładowe', 'start': 8, 'end': 19},
            {'text': 'zdanie', 'start': 20, 'end': 26},
            {'text': 'z', 'start': 27, 'end': 28},
            {'text': 'błędami', 'start': 29, 'end': 36}
        ]
        
        with patch('random.randint', return_value=3):
            with patch('random.sample', return_value=[
                {'text': 'przykładowe', 'start': 8, 'end': 19},
                {'text': 'zdanie', 'start': 20, 'end': 26},
                {'text': 'błędami', 'start': 29, 'end': 36}
            ]):
                with patch('spellcheck.generate_typo_distractor') as mock_distractor:
                    mock_distractor.side_effect = ['przykładówe', 'zdaine', 'błendami']
                    
                    result_page, result_words = spellcheck.generate_riddle(page)
        
        self.assertIn("\033[91m", result_page)
        self.assertIn("\033[0m", result_page)
        self.assertEqual(len(result_words), 3)
        self.assertEqual(result_words[0][0], "przykładowe")
        self.assertEqual(result_words[0][1], "przykładówe")
        self.assertEqual(result_words[1][0], "zdanie")
        self.assertEqual(result_words[1][1], "zdaine")
        self.assertEqual(result_words[2][0], "błędami")
        self.assertEqual(result_words[2][1], "błendami")
    
    @patch('spellcheck.get_token_info')
    def test_generate_riddle_no_maskable_tokens(self, mock_token_info):
        page = "Ja i ty"
        mock_token_info.return_value = [
            {'text': 'Ja', 'start': 0, 'end': 2},
            {'text': 'i', 'start': 3, 'end': 4},
            {'text': 'ty', 'start': 5, 'end': 7}
        ]
        
        result_page, result_words = spellcheck.generate_riddle(page)
        
        self.assertEqual(result_page, page)
        self.assertEqual(result_words, [])
    
    @patch('spellcheck.get_token_info')
    def test_generate_riddle_few_tokens(self, mock_token_info):
        page = "Długie słowo"
        mock_token_info.return_value = [
            {'text': 'Długie', 'start': 0, 'end': 6},
            {'text': 'słowo', 'start': 7, 'end': 12}
        ]
        
        with patch('random.randint', return_value=1):
            with patch('random.sample', return_value=[
                {'text': 'Długie', 'start': 0, 'end': 6}
            ]):
                with patch('spellcheck.generate_typo_distractor', return_value="Duglie"):
                    result_page, result_words = spellcheck.generate_riddle(page)
        
        self.assertEqual(len(result_words), 1)
        self.assertIn("\033[91mDuglie\033[0m", result_page)
    
    @patch('spellcheck.get_token_info')
    def test_generate_riddle_max_words(self, mock_token_info):
        page = " ".join([f"word{i}" for i in range(10)])
        mock_token_info.return_value = [
            {'text': f'word{i}', 'start': i*6, 'end': i*6+5} for i in range(10)
        ]
        
        with patch('random.randint', return_value=8):
            with patch('random.sample', return_value=[
                {'text': f'word{i}', 'start': i*6, 'end': i*6+5} for i in range(8)
            ]):
                with patch('spellcheck.generate_typo_distractor') as mock_distractor:
                    mock_distractor.side_effect = [f'wrod{i}' for i in range(8)]
                    
                    result_page, result_words = spellcheck.generate_riddle(page)
        
        self.assertEqual(len(result_words), 8)

class TestCollectWordFeatures(unittest.TestCase):
    @patch('spellcheck.read_page')
    def test_collect_word_features_basic(self, mock_read_page):
        mock_read_page.side_effect = ["To jest test.", "Kolejna strona.", None]
        
        spellcheck.collect_word_features("test.txt")
        
        self.assertIsInstance(spellcheck.WORD_FEATURE_MAP, dict)
        self.assertIsInstance(spellcheck.PAGE_CONTENT_CACHE, dict)
    
    def tearDown(self):
        spellcheck.WORD_FEATURE_MAP.clear()
        spellcheck.PAGE_CONTENT_CACHE.clear()

class TestGenerateLevel(unittest.TestCase):
    @patch('spellcheck.collect_word_features')
    @patch('spellcheck.PAGE_CONTENT_CACHE', {'1': 'Page 1', '2': 'Page 2', '3': 'Page 3'})
    @patch('spellcheck.generate_riddle')
    def test_generate_level_multiple_pages(self, mock_generate_riddle, mock_collect):
        mock_generate_riddle.side_effect = [
            ("Page1_typo", [("correct1", "typo1")]),
            ("Page2_typo", [("correct2", "typo2")]),
            ("Page3_typo", [("correct3", "typo3")])
        ]
        
        result = spellcheck.generate_level("test.txt")
        
        self.assertEqual(len(result), 3)
        self.assertEqual(result[0], ("Page1_typo", [("correct1", "typo1")]))
        self.assertEqual(result[1], ("Page2_typo", [("correct2", "typo2")]))
        self.assertEqual(result[2], ("Page3_typo", [("correct3", "typo3")]))
        mock_collect.assert_called_once_with("test.txt")
    
    @patch('spellcheck.collect_word_features')
    @patch('spellcheck.PAGE_CONTENT_CACHE', {})
    def test_generate_level_no_pages(self, mock_collect):
        result = spellcheck.generate_level("empty.txt")
        self.assertEqual(result, [])
        mock_collect.assert_called_once_with("empty.txt")

class TestIntegration(unittest.TestCase):
    @patch('spellcheck.get_token_info')
    def test_full_typo_generation(self, mock_token_info):
        page = "Przyjaciel butelki z wodą"
        mock_token_info.return_value = [
            {'text': 'Przyjaciel', 'start': 0, 'end': 10},
            {'text': 'butelki', 'start': 11, 'end': 18},
            {'text': 'z', 'start': 19, 'end': 20},
            {'text': 'wodą', 'start': 21, 'end': 25}
        ]
        
        with patch('random.randint', return_value=2):
            with patch('random.sample', return_value=[
                {'text': 'Przyjaciel', 'start': 0, 'end': 10},
                {'text': 'butelki', 'start': 11, 'end': 18}
            ]):
                with patch('spellcheck.generate_typo_distractor') as mock_distractor:
                    mock_distractor.side_effect = ['Pżyjaciel', 'botelki']
                    
                    result_page, result_words = spellcheck.generate_riddle(page)
        
        self.assertEqual(result_words[0][0], "Przyjaciel")
        self.assertEqual(result_words[0][1], "Pżyjaciel")
        self.assertEqual(result_words[1][0], "butelki")
        self.assertEqual(result_words[1][1], "botelki")
        self.assertIn("\033[91mPżyjaciel\033[0m", result_page)
        self.assertIn("\033[91mbotelki\033[0m", result_page)

if __name__ == '__main__':
    unittest.main()